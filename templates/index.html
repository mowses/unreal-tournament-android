<!--
https://developer.mozilla.org/en-US/docs/Web/API/DeviceMotionEvent/accelerationIncludingGravity

For acceleration and accelerationIncludingGravity, those axes correspond to the following:
x: Represents the axis from West to East
y: Represents the axis from South to North
z: Represents the axis perpendicular to the ground
-->
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8"/>
	<title>Sensors</title>
	<script type="text/javascript" src="{{ url_for('static', filename = 'socket.io.min.js') }}"></script>
	<script type="text/javascript">
	function matrix_vector_multiply(matrix1, vec1) {
		var vec2 = [];
		vec2[0] = matrix1[0] * vec1[0];
		vec2[0] += matrix1[1] * vec1[1];
		vec2[0] += matrix1[2] * vec1[2];
		vec2[1] = matrix1[3] * vec1[0];
		vec2[1] += matrix1[4] * vec1[1];
		vec2[1] += matrix1[5] * vec1[2];
		vec2[2] = matrix1[6] * vec1[0];
		vec2[2] += matrix1[7] * vec1[1];
		vec2[2] += matrix1[8] * vec1[2];
		return vec2;
	}

	function vec_rotate(vec, angle) {
		var ang_cos = [];
		var ang_sin = [];
		var matrix1 = [];

		function cosv(angle) {
			return Math.cos(toRadians(angle));
		}

		function sinv(angle) {
			return Math.sin(toRadians(angle));
		}
		
		ang_cos[0] = cosv(angle[0]);
		ang_cos[1] = cosv(angle[1]);
		ang_cos[2] = cosv(angle[2]);
		
		ang_sin[0] = sinv(angle[0]);
		ang_sin[1] = sinv(angle[1]);
		ang_sin[2] = sinv(angle[2]);
		
		matrix1[0] = ang_cos[0] * ang_cos[1];
		matrix1[1] = -ang_cos[0] * ang_sin[1] * ang_sin[2] - ang_sin[0] * ang_cos[2];
		matrix1[2] = -ang_cos[0] * ang_cos[2] * ang_sin[1] - ang_sin[0] * ang_sin[2];
		matrix1[3] = ang_sin[0] * ang_cos[1];
		matrix1[4] = -ang_sin[0] * ang_cos[1] * ang_sin[2] + ang_cos[0] * ang_cos[2];
		matrix1[5] = -ang_sin[0] * ang_sin[1] * ang_cos[2] - ang_cos[0] * ang_sin[2];
		matrix1[6] = ang_sin[1];
		matrix1[7] = ang_cos[1] * ang_sin[2];
		matrix1[8] = ang_cos[1] * ang_cos[2];
		
		return matrix_vector_multiply(matrix1, vec);
	}

	function toDegrees (angle) {
		return angle * (180 / Math.PI);
	}

	function toRadians (angle) {
		return angle * (Math.PI / 180);
	}
	/*var noSleep = new NoSleep();

	function enableNoSleep() {
		noSleep.enable();
		document.removeEventListener('touchstart', enableNoSleep, false);
	}

	// Enable wake lock.
	// (must be wrapped in a user input event handler e.g. a mouse or touch handler)
	document.addEventListener('touchstart', enableNoSleep, false);
	noSleep.enable();*/
	</script>
	<script type="text/javascript">
		var events = {
			ts: 0,
			motion: {
				x: null,
				y: null,
				z: null
			},
			orientation: {
				pan: null,
				tilt: null,
				roll: null
			}
		}

		function motion(event) {
			events.motion = {
				x: parseFloat(event.accelerationIncludingGravity.x.toFixed(10)),
				y: parseFloat(event.accelerationIncludingGravity.y.toFixed(10)),
				z: parseFloat(event.accelerationIncludingGravity.z.toFixed(10))
			};

			var gravity = vec_rotate([0,0,9.8], [events.orientation.pan, -events.orientation.tilt, events.orientation.roll]);
			ace.innerHTML = "Accelerometer: <br/>" +
			"x:" + (events.motion.x) + "<br/>" +
			"y:" + (events.motion.y) + "<br/>" +
			"z:" + (events.motion.z) + "<br/>"/* +
			"gravity 0:" + gravity[0] + "<br/>" +
			"gravity 1:" + gravity[1] + "<br/>" +
			"gravity 2:" + gravity[2] + "<br/>"*/;

			//send_commands();
		}
		
		function orientation(event) {
			events.orientation = {
				pan: parseFloat(event.alpha.toFixed(10)),  // 0 to 360
				tilt: parseFloat(event.gamma.toFixed(10)),  // 0 to 90 0 to -90
				roll: parseFloat(event.beta.toFixed(10))
			};

			mag.innerHTML = "Magnetometer: <br/>" +
			"pan:" + events.orientation.pan + "<br/>" +
			"tilt:" + events.orientation.tilt + "<br/>" +
			"roll:" + events.orientation.roll;

			send_commands()
		}

		function start_sensors() {
			ace = document.getElementById("accelerometer");
			mag = document.getElementById("magnetometer");
			tsp = document.getElementById("timestamp");
			
			if(window.DeviceMotionEvent) {
				window.addEventListener("devicemotion", motion, false);
			} else {
				var status = document.getElementById("status");
				status.innerHTML = status.innerHTML.replace("is supported", "is not supported");
			}
			if (window.DeviceOrientationEvent) {
				window.addEventListener("deviceorientation", orientation, false);
			} else {
				var status = document.getElementById("status");
				status.innerHTML = status.innerHTML.replace("is supported", "is not supported");
			}
		}
	</script>
	<script type="text/javascript">
	var socket;
	
	function send_commands() {
		events.ts += 1;
		tsp.innerHTML = "Timestamp: <br/>" + events.ts;
		socket.emit('update data', events);
	}

	function connect_socket() {
		socket = io.connect('http://' + document.domain + ':' + location.port);
		socket.on('connect', function() {
			start_sensors();
		});
	}
	</script>
</head>
<body onload="connect_socket();">
	<div id="accelerometer"></div>
	<br/><br/>
	<div id="magnetometer"></div>
	<br/><br/>
	<div id="timestamp"></div>
	<br/><br/>
	<div id="status"><a href="http://www.w3.org/TR/orientation-event/" target="_blank">http://www.w3.org/TR/orientation-event/</a> is supported.</div>
</body>
</html>
